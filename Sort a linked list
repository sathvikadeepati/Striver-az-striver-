time-o(n+n+nlogn)
space-o(1)
class Solution{
 public static ListNode sortlinkedlist(ListNode head){
    ArrayList<Integer> a=new ArrayList<>();
    ListNode curr=head;
    while(curr!=null){
       a.add(curr.val);
       curr=curr.next;
   }
  Collections.sort(a);
   curr=head;
   for(int i=0;i<a.size();i++){
       curr.val=a.get(i);
       curr=curr.next;
   }
   return head;
  }
}
optimal
using merge sort 
time-o(nlogn)
space-o(1)
class Solution{
    public static ListNode mergeList(ListNode list1,ListNode list2){
         ListNode dummy=new ListNode(-1);
         ListNode curr=dummy;
         while(list1!=null && list2!=null){
             if(list1.data<=list2.data){
                curr.next=list1;
                list1=list1.next;
             }
            else{
                curr.next=list2;
                list2=list2.next;
            }
            curr=curr.next;
         }
      if(list1!=null) curr.next=list1;
      else curr.next=list2;
      return dummy.next;
     }
public static  ListNode findmiddleelement(ListNode head){
   ListNode slow=head;
   ListNode fast=head.next;
   while(fast!=null && fast.next!=null){
     slow=slow.next;
     fast=fast.next.next;
   }
  return slow;
}
public static ListNode sortlinkedlist(ListNode head){
   if(head==null || head.next==null) return head;
   ListNode middle=findmiddleelement(head);
   ListNode righthead=middle.next;
   middle.next=null;
   ListNode left=sortlinkedlist(head);
   ListNode right=sortlinkedlist(righthead);
   return mergeList(left,right);
}
  }
}
