//brute force timecomplexity-o(n3) beacause Creates a new string of length ≈ O(n)
2️⃣ Integer.parseInt(substring)
Parses digit-by-digit → O(n) so not o(n2) 
space-o(n2)- in worst every string store in proirity queue;

public class Main
{   public static String Reversewords(String s){
        PriorityQueue<Integer>pq= new PriorityQueue<>(Collections.reverseOrder());
		int n=s.length();
		for(int i=0;i<n;i++){
		    for(int j=i+1;j<=n;j++){
		        String substring=s.substring(i,j);
		        int num=Integer.parseInt(substring);
		        if(num%2==1){
		            pq.offer(num);
		        }
		    }
		}
		return pq.isEmpty()?" ":String.valueOf(pq.peek());
	}
	public static void main(String[] args) {
	    String s = "5347";
	    System.out.println(largestoddnumber(s));
	
	}
}
//optimal 
public class Main
{   public static String largestoddnumber(String s){
        int n=s.length();
        int idx=-1;
        for(int i=n-1;i>=0;i--){
            if((s.charAt(i)-'0')%2==1){
                idx=i;
                break;
            }
        }
        if(idx==-1) return "";
        int i=0;
        while(i<=idx && s.charAt(i)=='0'){
            i++;
        }
        return s.substring(i,idx+1);
	}
	public static void main(String[] args) {
	    String s = "5347";
	    System.out.println(largestoddnumber(s));
	
	}
}
//time-o(n) and space -o(1)
